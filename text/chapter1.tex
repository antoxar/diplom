\chapter{Теоретические основы}{Теоретические основы обнаружения уязвимостей и средств защиты от отладки}

\section{Уязвимость переполнения буфера}
\par По рейтингу TOP 25 CWE/SANS \cite{CWE_SANS_25}, согласованному списку проблем, связанных с уязвимостями ПО и требующих немедленного вмешательства и устранения, третье место среди всех типов, и первое среди уязвимостей в исполняемых файлах, занимает переполнение буфера.
\par <<Ошибки переполнения - это фундаментальные программистские ошибки, которые чрезвычайно трудно отслеживать и фундаментальность которых обеспечивается самой природой языка Си - наиболее популярного языка программирования, а точнее его низкоуровневым характером взаимодействия с памятью. Поддержка массивов реализована лишь частично и работа с ними требует чрезвычайной аккуратности и внимания со стороны программиста. Средства автоматического контроля выхода за границы отсутствуют, возможность определения количества элементов массива по указателю и проверка обращения к строкам, завещающимися нуль символами, тоже>> \cite{KasperBOWF}.
Малейшая небрежность и забытая, или некорректно реализованная проверка корректности аргументов, приводит к потенциальной уязвимости программы, а корректную проверку аргументов осуществить крайне тяжело. Рассмотрим функцию, определяющую длину переданной ей строки и посимвольно читающую эту строку до встречи с завершающим ее нулем. Если завершающего нуля на конце не окажется, то содержимое прилегающей памяти будет интерпретировано как продолжение строки. В лучшем случае это закончится выбросом исключения. В худшем - доступом к конфиденциальным данным. 
\par <<Выделение буфера возможно лишь после вычисления длины принимаемой структуры данных, т.е. должно осуществляться динамически. Это препятствует размещению буферов в стеке, поскольку стековые буфера имеют фиксированный размер, задаваемый еще на стадии компиляции. Зато стековые буфера автоматически освобождаются при выходе из функции, предотвращая при этом потенциальные проблемы с утечками памяти. Динамические память, намного менее популярна, поскольку ее использование уродует структуру программы. Если раньше обработка текущих ошибок сводилась к немедленному возврату, то теперь перед выходом из функции приходится выполнять специальный код, освобождающий все, что программист успел к этому времени выделить. Без goto, эта задача решается только глубоко вложенными условиями, обработчиками структурных исключений, макросами или внешними функциями, что служит источником многочисленных и трудноуловимых ошибок.
\par Многие библиотечные функции, например, gets, sprintf, не имеют никаких средств ограничения длины возвращаемых данных и легко вызывают ошибки переполнения. Руководства по безопасности запрещают использование последних, рекомендуя их безопасные аналоги - fgets и snprintf, явно специфицирующие предельно допустимую длину буфера, передаваемую в специальном аргументе. Помимо неоправданного загромождения листинга посторонними аргументами и естественных проблем с их синхронизацией, программист сталкивается с необходимостью контроля целостности обрабатываемых данных. Как минимум, необходимо убедиться, что данные не были варварски обрезаны или усечены, а как максимум - корректно обработать ситуацию с изменением размера. Здесь возможно увеличить буфер и повторно вызывать функцию, чтобы скопировать туда остаток, но не слишком-то элегантное решение, к тому же всегда существует вероятность потерять завершающий нуль на конце.
\par В Си++ ситуация с переполнением обстоит намного лучше, хотя проблем все равно хватает. Поддержка динамических массивов и <<прозрачных>> текстовых строк наконец-то появилась, но подавляющее большинство реализаций динамических массивов работают крайне медленно, как и строки, поэтому, в критических участках кода, от них лучше сразу же отказаться. Иначе и быть не может, поскольку существует только один способ построения динамических массивов переменной длины - представление их содержимого в виде ссылочной структуры, например в виде двунаправленного списка. Для быстрого доступа к произвольному элементу список нужно индексировать, а саму таблицу индексов где-то хранить. Таким образом, чтение или запись одного единственного символа выливается в десятки машинных команд и множество обращений к памяти>>\cite{KasperBOWF}.
\par Даже если компилятор будет проверять границы массива, а это одно дополнительное обращение к памяти и три-четыре машинных команды, это не решит проблемы, поскольку при обнаружении переполнения откомпилированная программа аварийно завершится.
\section{Переполнение буфера на стеке и области памяти}
\par Переполнение буфера в виде переполнения стека возникает, когда буфер, выделенный на стеке, перезаписывается данными, объем которых превосходит его размер. Этот тип переполнений встречаются наиболее часто, потому что размер таких буферов жестко определяется еще на этапе компиляции, а процедура проверки корректности обрабатываемых данных зачастую отсутствует или реализована с грубыми ошибками. Опасность их заключается в том, что в непосредственной близости от буферов на стеке присутствуют адрес возврата из функции, модификация которого позволяет злоумышленнику осуществить передачу управления на произвольный код.
\par Стек -  структура данных с методом доступа к элементам LIFO (последним пришел — первым вышел). На рисунке \ref{seh:fig} изображен кадр стека функции, в которой присутствует структурный обработчик исключений. На рисунке \ref{seh:virtmem} отображена схема организация виртуальной памяти.

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.6]{seh}
\caption{\label{seh:fig}%
Карта стека функции с SEH.
}
\end{figure}

\par За адресом возврата(Saved Return Address) на стеке содержится указатель на фрейм родительской функции (Saved Ebp), сохраняемый компилятором перед открытием фрейма дочерней функции. Вообще-то, оптимизирующие компиляторы, поддерживающие технологию <<плавающих фреймов>>, обходятся и без этого, используя регистр-указатель вершины кадра как обычный регистр общего назначения, однако даже поверхностный анализ обнаруживает большое количество уязвимых приложений с кадром внутри, так что этот прием атаки все еще остается актуальным. Модификация кадра стека срывает адресацию локальных переменных и аргументов родительской функции и дает возможность управлять ими по своему усмотрению. Установив кадр родительской функции на свой буфер, злоумышленник может подменить родительские переменные (аргументы). 
\par Затем, если в функции используется структурная обработка исключений, на стеке хранится структура \_EXCEPTION\_REGISTRATION, прототип функции описан в листинге \ref{excreg:list} \cite{SEH}.

\begin{lstlisting}[caption=Описание структуры \_EXCEPTION\_REGISTRATION,
  label=excreg:list]
struct _EXCEPTION_REGISTRATION
{
      struct _EXCEPTION_REGISTRATION *prev;
      void (*handler)( PEXCEPTION_RECORD,
                       PEXCEPTION_REGISTRATION,
                       PCONTEXT,
                       PEXCEPTION_RECORD);
      struct scopetable_entry *scopetable;
      int trylevel;
}
\end{lstlisting}
\textit{prev} - указатель  на предыдущий обработчик исключений;\\
\textit{handler} - текущий обработчик исключений;\\
\textit{scopetable\_entry} - указатель на структуру, содержащую информацию о вложенности структурных исключений, при наличие этого указателя используется только 1 структура EXCEPTION\_REGISTRATION  для всего потока \cite{SEH};\\
\textit{trylevel} - количество вложенных SEH.


\begin{figure}[!ht]
\centering
\includegraphics[scale=0.4]{virtmem}
\caption{\label{seh:virtmem}%
Организация виртуальной памяти.
}
\end{figure}
\section{Методы обнаружения переполнения буфера}
\label{sec:detection}
\par Методы обнаружения подразделяются на ручные и автоматические.
Ручной поиск уязвимостей подразделяется на 2 категории. Первая используется аналитиками при наличие исходных кодов. При таком анализе специалистам приходится собственноручно просматривать код, что занимает довольно много времени, гарантирует обнаружение недокументированных возможностей. 
\par Существуют ситуации, в которых исходные коды недоступны, тогда анализ проводится по исполняемому коду. Такого рода исследования проводятся не только для анализа вирусов, плагиата, но и для поиска ошибок и недокументированных возможностей. В данном случае специалист, используя дизассемблер, декомпилятор и отладчик восстанавливает логику программы. Учитывая трудоемкость исследования, специалисту не обойтись без специализированных средств, таких как свободно распространяемы <<PaiMai>> от Pedram Amini, или <<BinNavi>> от компании <<Zynamics>>. Такие средства строят трассы, графы взаимодействия функциональных единиц. Применение их позволяют, сократит время исследования в несколько раз.
Поиск уязвимости по шаблону - автоматизированный метод, основанный на сравнении некоторых характеристик исследуемого ПО с заранее подготовленными описаниями (сигнатурами) уязвимых мест. Данный метод эффективен при поиске несложных уязвимостей  и немаскируемых закладок, таких как переполнение буфера, парольные константы и т.д.
\par Поиск уязвимостей по шаблонам проводится статически. При статическом анализе исследуется код программы без его запуска. Код программного обеспечения сравнивается с сигнатурами из базы методом побайтового сравнения или по более сложному алгоритму. При обнаружении сходств, сообщается о найденной уязвимости. 
\par Современные сканеры кода позволяют хорошо справляются с автоматизацией шаблонного поиска следующих типов уязвимостей \cite{example3}:
\begin{itemize}
\item внедрение произвольных команд; 
\item SQL-инъекции; 
\item XSS-запросы (межсайтовый скриптинг); 
\item ошибки входных и выходных значений; 
\item уязвимости переполнения буфера.
\end{itemize}
\par К автоматизированным средствам проведения статического метода по шаблону относят сканеры уязвимостей кода PREfix, PREfast, АК-ВС, UCA, FlawFinder, ITS4, RATS, FxCop. Все они поддерживают поиск ошибок в модулях исходного кода, написанных на одном из поддерживаемых языков. 
\par Недостатком метода является невозможность обнаружения уязвимостей, для которых отсутствуют сигнатуры. 
Другой автоматизированный метод, фаззинг (fuzzing) - технология тестирования программного обеспечения, при которой вместо ожидаемых входных данных программе передаются случайные или специально сформированные данные. В большинстве своем это некорректно составленные данные. Такая проверка сводится к тому, что программист не знает, какие данные будут переданы приложению, протоколу или функции, поэтому его задача предусмотреть и проверить как можно больше вариаций. Данные передаются на вход программным интерфейсам, включающим:
\begin{itemize}
\item файлы;
\item сетевые порты;
\item API.
\end{itemize}
\par В случае если программа зависает или аварийно завершает работу, считается, что найден дефект, который может привести к обнаружению определенной уязвимости. Самым простым примером может служить переполнение буфера. Умный злоумышленник может составить грамотный запрос, содержащий вредоносный код и данные, которые вызовут переполнение. Причем приложение может и не завершить свою работу, но обязательно выполнит код. Та же самая ситуация складывается и с обработкой данных из файлов и протоколов, обработкой передаваемых параметров функции и прочим.
\par <<Примером неверной обработки файлов служат найденные с помощью фаззинга ошибки в файлах XLS, PPT, DOC и BMP. И это неудивительно, ведь синтаксический анализ сложных структур данных – это сложная задача, сложный код будет иметь ошибки, и некоторые из этих ошибок могут выявить уязвимости безопасности. Именно такие участки кода, занимающиеся анализом каких либо данных, должны быть проверены в первую очередь. 
\par Фаззинг является динамической технологией тестирования безопасности. Средства статического анализа кода позволяют обрабатывать большее количество кода благодаря автоматизации, но результаты строго ограничены и могут быть ложными. Фаззинг же динамичен, он не имеет строгих шаблонов и критериев, и может быть просто автоматизирован, выполняясь непрерывно. При разработке запросов необходимо собирать статистику исполнения участков кода, и в дальнейшем строить запросы, позволяющие покрыть самые уделенные части кода>> \cite{example4}.
К современным фаззерам относятся OWASP JBroFuzz, Bunny the Fuzzer, SPIKE, PFF (Php Fuzzing Framework), ProxyFuzz, а также свободно распространяемый Framework для Фаззига от Pedram Amini. 

\clearpage