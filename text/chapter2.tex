\chapter{Уязвимость форматной строки}

\par Ошибки форматного вывода малочисленны и встречаются главным образом в UNIX-приложениях, где традиции терминального режима все еще остаются сильны. По некоторым оценкам, в 2002 году было обнаружено порядка 100 уязвимых приложений, а в 2003 – свыше 150. Атаке подверглись сервера баз данных, вращающихся под Oracle и сервисы UNIX, такие, например, как syslog или ftp. Ни одной атаки на приложения Windows NT до сих пор не зафиксировано. Это не значит, что Windows NT лучше, просто графический интерфейс не располагает к интенсивному использованию форматного вывода, да и количество консольных утилит под NT очень невелико.

\section{Функции форматированного вывода}
\par Услугами интерпретатора форматного ввода/вывода пользуется множество функций, не только printf и не только в консольных программах. Графические приложения и серверное программное обеспечение, исполняющееся под Windows NT, активно использует функцию sprintf, выводящую отформатированную строку в оперативный буфер. Функции, перечисленные в таблице \ref{tab:Functions} \cite{example3}, сами по себе не опасны. Опасными их делает наличие пользовательского ввода в форматном аргументе. Именно такие участки кода и нужно искать при исследовании программы на уязвимость.

%\begin{longtable}{|c|c|p{110mm}|}
% \multicolumn{3}{l}{\tablename~\thetable~---~Пример таблицы\label{T:T1}}\\\hline
% Название 1  & Название 2 & Название 3 \\
%\hline
%\endfirsthead
% \multicolumn{3}{l}{Продолжение таблицы~\ref{T:T1}}\\
%\hline
%1 & 2 & 3 \\
%\hline
%\endhead
%Это  & пример & данных  \\
%\hline
%помещённых & внутрь & таблицы \\
%\hline
%\end{longtable}


\begin{longtable}{|l|l|l|}
\caption{Пример таблицы} \label{tab:Functions} \\

\hline {\textbf{Time (s)}} & {\textbf{Triple chosen}} & {\textbf{Other feasible triples}} \\ \hline 
\endfirsthead

\multicolumn{3}{r}%
{{ Продолжение таблицы \thetable{} }} \\
\hline \multicolumn{1}{|c|}{\textbf{Time (s)}} &
\multicolumn{1}{c|}{\textbf{Triple chosen}} &
\multicolumn{1}{c|}{\textbf{Other feasible triples}} \\ \hline 
\endhead

%\hline \multicolumn{3}{|r|}{{Continued on next page}} \\ \hline
%\endfoot

\hline
\endlastfoot

0 & (1, 11, 13725) & (1, 12, 10980), (1, 13, 8235), (2, 2, 0), (3, 1, 0) \\
\hline
2745 & (1, 12, 10980) & (1, 13, 8235), (2, 2, 0), (2, 3, 0), (3, 1, 0) \\
\hline
5490 & (1, 12, 13725) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
8235 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
10980 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
13725 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
16470 & (1, 13, 16470) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
19215 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
21960 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
24705 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
27450 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
30195 & (2, 2, 2745) & (2, 3, 0), (3, 1, 0) \\
\hline
32940 & (1, 13, 16470) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
35685 & (1, 13, 13725) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
38430 & (1, 13, 10980) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
41175 & (1, 12, 13725) & (1, 13, 10980), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
43920 & (1, 13, 10980) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
46665 & (2, 2, 2745) & (2, 3, 0), (3, 1, 0) \\
\hline
49410 & (2, 2, 2745) & (2, 3, 0), (3, 1, 0)
\end{longtable}


\section{Защита от  уязвимостей форматной строки}
\par Рассмотрим, что можно сделать для защиты от атак на данную уязвимость.
Прежде всего, это аудит исходного кода, в том числе и с использованием автоматических сканеров.
Использование макросов-подстановок вместо оригинальных функций, воспринимающих форматные строки. Таким образом, все вызовы потенциально уязвимых функций перенаправляются в вызовы другой функции, которая проверяет число аргументов и число спецификаторов \%. Если эти числа равны, управление передается оригинальной функции, иначе - вызов завершается с ошибкой. На основе данной методики был разработан продукт FormatGuard, который реализован в виде модифицированной версии glibc 2.2. Для защиты требуется перекомпиляция программы с модифицированной версией glibc.	Применение фильтрации для обнаружения и исключения <<опасных>> форматных спецификаторов, таких как \%n. Эта методика реализуется в Libformat. Libformat представляет собой динамическую библиотеку, которая экспортирует функции libc, воспринимающие форматные спецификаторы. Данная библиотека указывается в LD\_PRELOAD, что позволяет перехватывать вызовы всех потенциально уязвимых функций. При обнаружении форматной строки, содержащей спецификатор \%n, Libformat формирует запись в syslog и завершает текущий процесс. Важно, что при этом не требуется перекомпиляция программы \cite{example4}.
\section{Методы обнаружения ошибок форматного вывода}
\par Методы обнаружения уязвимостей, обеспечивающие покрытие для ошибок форматного ввода приведены в пункте \ref{sec:detection}. Ссылка на приложение \ref{apx:Spec}

Списки и перечни можно друг в друга вкладывать, то есть можно делать так:

\begin{enumerate}% начало нумерованного списка
\item Первый.% первая нумерованная запись
	\begin{enumerate}
	\item Первый первый
	\item Первый второй
	\begin{itemize}
	\item Первый второй первый
	\item Первый второй второй
	\end{itemize}
	\end{enumerate}
\item Второй.% вторая нумерованная запись
\end{enumerate}% конец нумерованного списка

\par  В \ref{eq:fourierrow} изображена формула разложения в ряд Фурье. Примеры формул в тексте приведено ниже.
\begin{equation}\label{eq:fourierrow}
f(x) =
\frac{A_0}{2}
+
\sum \limits_{n=1}^{\infty} A_n \cos \left( \frac{2 n \pi x}{\nu} - \alpha_n \right)
\end{equation}
\par A grammar is formally defined as the tuple (N,$\Sigma$,P,S), where
\begin{itemize}
\item a finite set N of nonterminal symbols, none of which appear in strings formed from G;
\item a finite set $\Sigma$ of terminal symbols that is disjoint from N;
\item P is a rewriting system, that is to say a finite set of rules $P \subseteq ( \Sigma \bigcup N )^\ast\times( \Sigma \bigcup N )^\ast$, 
such that $(\upsilon, \nu) \in P \Longrightarrow \upsilon \in \Sigma $; 
\item A distinguished symbol $S \in N $ that is the start symbol.
\end{itemize}	
\par Such a formal grammar is often called a rewriting system or a phrase structure grammar in the literature. 
A formal language is finally defined by the set of words $L(G) = {x \in \Sigma^\ast |S \rightarrow^\ast x}$ with respect to the grammar G = (N,$\Sigma$,P,S).

