\chapter{Уязвимость форматной строки}

\par Ошибки форматного вывода малочисленны и встречаются главным образом в UNIX-приложениях, где традиции терминального режима все еще остаются сильны. По некоторым оценкам, в 2002 году было обнаружено порядка 100 уязвимых приложений, а в 2003 – свыше 150. Атаке подверглись сервера баз данных, вращающихся под Oracle и сервисы UNIX, такие, например, как syslog или ftp. Ни одной атаки на приложения Windows NT до сих пор не зафиксировано. Это не значит, что Windows NT лучше, просто графический интерфейс не располагает к интенсивному использованию форматного вывода, да и количество консольных утилит под NT очень невелико.

\section{Функции форматированного вывода}
\par Услугами интерпретатора форматного ввода/вывода пользуется множество функций, не только printf и не только в консольных программах. Графические приложения и серверное программное обеспечение, исполняющееся под Windows NT, активно использует функцию sprintf, выводящую отформатированную строку в оперативный буфер. Функции, перечисленные в таблице \ref{tab:Functions} \cite{example3}, сами по себе не опасны. Опасными их делает наличие пользовательского ввода в форматном аргументе. Именно такие участки кода и нужно искать при исследовании программы на уязвимость.

%\begin{longtable}{|c|c|p{110mm}|}
% \multicolumn{3}{l}{\tablename~\thetable~---~Пример таблицы\label{T:T1}}\\\hline
% Название 1  & Название 2 & Название 3 \\
%\hline
%\endfirsthead
% \multicolumn{3}{l}{Продолжение таблицы~\ref{T:T1}}\\
%\hline
%1 & 2 & 3 \\
%\hline
%\endhead
%Это  & пример & данных  \\
%\hline
%помещённых & внутрь & таблицы \\
%\hline
%\end{longtable}


\begin{longtable}{|l|l|l|}
\caption{Пример таблицы} \label{tab:Functions} \\

\hline {\textbf{Time (s)}} & {\textbf{Triple chosen}} & {\textbf{Other feasible triples}} \\ \hline 
\endfirsthead

\multicolumn{3}{r}%
{{ Продолжение таблицы \thetable{} }} \\
\hline \multicolumn{1}{|c|}{\textbf{Time (s)}} &
\multicolumn{1}{c|}{\textbf{Triple chosen}} &
\multicolumn{1}{c|}{\textbf{Other feasible triples}} \\ \hline 
\endhead

%\hline \multicolumn{3}{|r|}{{Continued on next page}} \\ \hline
%\endfoot

\hline
\endlastfoot

0 & (1, 11, 13725) & (1, 12, 10980), (1, 13, 8235), (2, 2, 0), (3, 1, 0) \\
\hline
2745 & (1, 12, 10980) & (1, 13, 8235), (2, 2, 0), (2, 3, 0), (3, 1, 0) \\
\hline
5490 & (1, 12, 13725) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
8235 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
10980 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
13725 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
16470 & (1, 13, 16470) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
19215 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
21960 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
24705 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
27450 & (1, 12, 16470) & (1, 13, 13725), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
30195 & (2, 2, 2745) & (2, 3, 0), (3, 1, 0) \\
\hline
32940 & (1, 13, 16470) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
35685 & (1, 13, 13725) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
38430 & (1, 13, 10980) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
41175 & (1, 12, 13725) & (1, 13, 10980), (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
43920 & (1, 13, 10980) & (2, 2, 2745), (2, 3, 0), (3, 1, 0) \\
\hline
46665 & (2, 2, 2745) & (2, 3, 0), (3, 1, 0) \\
\hline
49410 & (2, 2, 2745) & (2, 3, 0), (3, 1, 0)
\end{longtable}


\section{Защита от  уязвимостей форматной строки}
\par Рассмотрим, что можно сделать для защиты от атак на данную уязвимость.
Прежде всего, это аудит исходного кода, в том числе и с использованием автоматических сканеров.
Использование макросов-подстановок вместо оригинальных функций, воспринимающих форматные строки. Таким образом, все вызовы потенциально уязвимых функций перенаправляются в вызовы другой функции, которая проверяет число аргументов и число спецификаторов \%. Если эти числа равны, управление передается оригинальной функции, иначе - вызов завершается с ошибкой. На основе данной методики был разработан продукт FormatGuard, который реализован в виде модифицированной версии glibc 2.2. Для защиты требуется перекомпиляция программы с модифицированной версией glibc.	Применение фильтрации для обнаружения и исключения <<опасных>> форматных спецификаторов, таких как \%n. Эта методика реализуется в Libformat. Libformat представляет собой динамическую библиотеку, которая экспортирует функции libc, воспринимающие форматные спецификаторы. Данная библиотека указывается в LD\_PRELOAD, что позволяет перехватывать вызовы всех потенциально уязвимых функций. При обнаружении форматной строки, содержащей спецификатор \%n, Libformat формирует запись в syslog и завершает текущий процесс. Важно, что при этом не требуется перекомпиляция программы \cite{example4}.
\section{Методы обнаружения ошибок форматного вывода}
\par Методы обнаружения уязвимостей, обеспечивающие покрытие для ошибок форматного ввода приведены в пункте \ref{sec:detection}. Ссылка на приложение \ref{apx:Spec}

